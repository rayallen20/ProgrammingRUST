fn main() {
    // 100 * 200 可以表示为u16
    assert_eq!(100_u16.wrapping_mul(200), 20000);

    // 500 * 500 不能表示为u16 其结果为 250000 % 2^16 = 250000 % 65536 = 53392
    assert_eq!(500_u16.wrapping_mul(500), 53392);

    // 对右符号类型的运算可能会回绕为负值
    // 这是因为在计算机中,负数是以补码的形式存储的
    // TODO: 这里我也不知道为啥是-12144 但我觉得这不是重点
    assert_eq!(500_i16.wrapping_mul(500), -12144);

    // 在移位运算中,移位距离会在值的大小范围内回绕
    // 因此 在i16中移动17位 相当于移动了1位
    assert_eq!(5_i16.wrapping_shl(17), 10);
}
